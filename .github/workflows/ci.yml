name: CI

on:
  pull_request:
    branches: ['**']

jobs:
  test:
    runs-on: patient_staging_test
      
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python 3.9
        uses: actions/setup-python@v3
        with:
          python-version: '3.9.19'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: Create .env file
        run: |
          cat <<EOF > .env
          # Database
          DB_SERVER_DEV=${{ secrets.DB_SERVER_DEV }}
          DB_DATABASE_DEV=${{ secrets.DB_DATABASE_DEV }}
          DB_DATABASE_PORT=${{ secrets.DB_DATABASE_PORT }}
          DB_USERNAME_DEV=${{ secrets.DB_USERNAME_DEV }}
          DB_PASSWORD_DEV=${{ secrets.DB_PASSWORD_DEV }}
          DB_DRIVER_DEV=${{ secrets.DB_DRIVER_DEV }}
          
          # Cloudinary
          CLOUDINARY_CLOUD_NAME=${{ secrets.CLOUDINARY_CLOUD_NAME }}
          CLOUDINARY_API_KEY=${{ secrets.CLOUDINARY_API_KEY }}
          CLOUDINARY_API_SECRET=${{ secrets.CLOUDINARY_API_SECRET }}
          
          # Web
          WEB_FE_ORIGIN=${{ secrets.WEB_FE_ORIGIN }}
          
          # RabbitMQ
          RABBITMQ_HOST=localhost
          RABBITMQ_PORT=5672
          RABBITMQ_USER=testuser
          RABBITMQ_PASS=testpassword
          RABBITMQ_VIRTUAL_HOST=/
          RABBITMQ_DEFAULT_USER=testuser
          RABBITMQ_DEFAULT_PASS=testpassword
          EOF
          grep -v 'PASSWORD' .env

      - name: Start RabbitMQ
        run: |
          # Create configuration directory and file
          mkdir -p rabbitmq-config
          cat << EOF > rabbitmq-config/rabbitmq.conf
          # Disable cluster peer discovery
          cluster_formation.peer_discovery_backend = classic_config

          
          # Enable management plugin
          management.tcp.port = 15672
          management.tcp.ip = 0.0.0.0
          
          # Log to stdout
          log.console = true
          log.console.level = info
          EOF

          # Create a custom entrypoint script to handle cookie permissions
          cat << 'EOF' > rabbitmq-entrypoint.sh
          #!/bin/bash
          set -e
          
          # Ensure directory exists
          mkdir -p /var/lib/rabbitmq
          
          # Set Erlang cookie with proper permissions
          echo "TESTCOOKIE123" > /var/lib/rabbitmq/.erlang.cookie
          chown rabbitmq:rabbitmq /var/lib/rabbitmq/.erlang.cookie
          chmod 600 /var/lib/rabbitmq/.erlang.cookie
          
          
          # Start RabbitMQ
          exec docker-entrypoint.sh rabbitmq-server
          EOF
          
          chmod +x rabbitmq-entrypoint.sh
          
          # Start container with configuration
          docker run -d \
            --name rabbitmq \
            --memory="800m" \
            -e RABBITMQ_ERLANG_COOKIE="TESTCOOKIE123" \
            -e RABBITMQ_DEFAULT_USER=testuser \
            -e RABBITMQ_DEFAULT_PASS=testpassword \
            -v $(pwd)/rabbitmq-config:/etc/rabbitmq \
            -v $(pwd)/rabbitmq-entrypoint.sh:/usr/local/bin/custom-entrypoint \
            --entrypoint /usr/local/bin/custom-entrypoint \
            -p 5672:5672 \
            -p 15672:15672 \
            192.168.188.184:5000/rabbitmq_service_dev:latest
          
          echo "Waiting for RabbitMQ to start..."
          for i in {1..30}; do
            if ! docker ps | grep -q rabbitmq; then
              echo "RabbitMQ container crashed!"
              docker logs rabbitmq
              exit 1
            fi
            if docker exec rabbitmq rabbitmq-diagnostics -q ping >/dev/null 2>&1 && \
               docker exec rabbitmq rabbitmqctl await_startup >/dev/null 2>&1; then
              echo "RabbitMQ is fully ready!"
              docker exec rabbitmq rabbitmqctl list_users
              break
            fi
            sleep 2
          done
          if [ $i -eq 30 ]; then
            echo "RabbitMQ failed to start within 60 seconds"
            docker logs rabbitmq
            exit 1
          fi

      - name: Verify RabbitMQ
        run: |
          docker ps -a
          nc -vz localhost 5672
          docker exec rabbitmq rabbitmqctl status

      - name: Run tests with timeout and debug on hang
        run: |
          # Run pytest with timeout of 120 seconds, so it doesn't hang forever
          timeout 120s pytest -v \
            --durations=10 \
            --capture=no \
            --disable-warnings \
            --junitxml=test-results.xml
          TEST_EXIT_CODE=$?

          echo "===== TESTS FINISHED WITH EXIT CODE $TEST_EXIT_CODE ====="
          echo "--- Running docker ps ---"
          docker ps -a

          echo "--- Showing RabbitMQ logs (last 100 lines) ---"
          docker logs --tail 100 rabbitmq || echo "No rabbitmq logs found"

          echo "--- Running processes on runner ---"
          ps aux | head -40

          echo "--- Open files (lsof) ---"
          lsof -nP | head -40 || echo "lsof not available"

          # Exit with test exit code so failures are caught
          exit $TEST_EXIT_CODE

      - name: Cleanup
        if: always()
        run: |
          docker stop rabbitmq || true
          docker rm rabbitmq || true