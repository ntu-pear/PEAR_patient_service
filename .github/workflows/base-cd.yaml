name: Base CD

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      runner-label:
        required: true
        type: string
      kube-deployment-file:
        required: true
        type: string
      filebeat-daemonset-file:
        required: false
        type: string
      dockerfile:
        required: false
        type: string
        default: Dockerfile.dev
      docker-image-name:
        required: false
        type: string
        default: patient_service_dev
      docker-image-tag:
        required: false
        type: string
        default: latest
    # These are passed in from cd.yml
    secrets:
      DB_SERVER:
        required: true
      DB_DATABASE:
        required: true
      DB_DATABASE_PORT:
        required: true
      DB_USERNAME:
        required: true
      DB_PASSWORD:
        required: true
      DB_DRIVER:
        required: true
      CLOUDINARY_CLOUD_NAME:
        required: true
      CLOUDINARY_API_KEY:
        required: true
      CLOUDINARY_API_SECRET:
        required: true
      WEB_FE_ORIGIN:
        required: true
      RABBITMQ_HOST:
        required: true
      RABBITMQ_PORT:
        required: true
      RABBITMQ_USER:
        required: true
      RABBITMQ_PASS:
        required: true
      RABBITMQ_VIRTUAL_HOST:
        required: true

jobs:
  deploy:
    runs-on: ${{ inputs.runner-label }}
    environment: ${{ inputs.environment }}

    steps:
      - uses: actions/checkout@v4

      - name: Print working directory
        run: |
          pwd
          ls -la
          git status

      - name: Set commit SHA
        id: vars
        run: |
          echo "COMMIT_SHA=$(git rev-parse --short HEAD)" >> $GITHUB_ENV

      - name: Create .env file from base-cd.yml
        run: |

          echo "SERVICE_NAME=${{ vars.SERVICE_NAME }}" >> .env  # Taken directly from GitHub settings, not cd.yml
          
          # Database
          echo "DB_SERVER=${{ secrets.DB_SERVER }}" >> .env
          echo "DB_DATABASE=${{ secrets.DB_DATABASE }}" >> .env
          echo "DB_DATABASE_PORT=${{ secrets.DB_DATABASE_PORT }}" >> .env
          echo "DB_USERNAME=${{ secrets.DB_USERNAME }}" >> .env
          echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> .env
          echo "DB_DRIVER=${{ secrets.DB_DRIVER }}" >> .env
          
          # Cloudinary
          echo "CLOUDINARY_CLOUD_NAME=${{ secrets.CLOUDINARY_CLOUD_NAME }}" >> .env
          echo "CLOUDINARY_API_KEY=${{ secrets.CLOUDINARY_API_KEY }}" >> .env
          echo "CLOUDINARY_API_SECRET=${{ secrets.CLOUDINARY_API_SECRET }}" >> .env

          # Origins
          echo "WEB_FE_ORIGIN=${{ secrets.WEB_FE_ORIGIN }}" >> .env

          # RabbitMQ
          echo "RABBITMQ_HOST=${{ secrets.RABBITMQ_HOST }}" >> .env
          echo "RABBITMQ_PORT=${{ secrets.RABBITMQ_PORT }}" >> .env
          echo "RABBITMQ_USER=${{ secrets.RABBITMQ_USER }}" >> .env
          echo "RABBITMQ_PASS=${{ secrets.RABBITMQ_PASS }}" >> .env
          echo "RABBITMQ_VIRTUAL_HOST=${{ secrets.RABBITMQ_VIRTUAL_HOST }}" >> .env

      - name: Create Kubernetes Secret
        run: |
            kubectl delete secret patient-service-secret --ignore-not-found
            kubectl create secret generic patient-service-secret \
            --from-literal=ES_HOST="${{ secrets.ES_HOST_STAGING }}" \
            --from-literal=ES_PORT="${{ secrets.ES_PORT }}" \
            --from-literal=ES_USERNAME="${{ secrets.ES_USERNAME }}" \
            --from-literal=ES_PASSWORD="${{ secrets.ES_PASSWORD_STAGING }}"

      - name: Apply Kubernetes ConfigMap
        run: |
          echo "Applying ConfigMap..."
          kubectl apply -f './k8s/configmap.yaml'
          kubectl apply -f './k8s/secret.yaml'

      - name: Build Docker image
        run: |
          echo "Building Docker image with commit SHA"
          docker build --no-cache -f Dockerfile.dev -t patient_service_dev:${{ env.COMMIT_SHA }} .

      - name: Tag Docker image
        run: |
          echo "Tagging Docker image..."
          docker tag patient_service_dev:${{ env.COMMIT_SHA }} localhost:5000/patient_service_dev:${{ env.COMMIT_SHA }}

      - name: Push Docker image to local registry
        run: |
          echo "Pushing Docker image to localhost:5000..."
          docker push localhost:5000/patient_service_dev:${{ env.COMMIT_SHA }}

      - name: Ensure deployment exists
        run: |
          kubectl get deployment patient-service-dev || kubectl apply -f '${{ inputs.kube-deployment-file }}'

      - name: Deploy to Kubernetes (rolling update)
        run: |
          echo "Updating deployment with commit SHA image..."
          kubectl set image deployment/patient-service-dev \                               # Overwrites image defined in deployment manifest
            patient-service=host.minikube.internal:5000/patient_service_dev:${{ env.COMMIT_SHA }}

          kubectl rollout status deployment/patient-service-dev --timeout=300s

      - name: Deploy filebeat DaemonSet to Kubernetes
        if: ${{ inputs.filebeat-daemonset-file != '' }}
        run: |
          echo "Deploying filebeat DaemonSet..."
          kubectl apply -f '${{ inputs.filebeat-daemonset-file }}'

      - name: Docker maintenace cleanup
        run: |
          echo "Running Docker maintenance cleanup..."
          # Removes any image not currently referenced by a container
          docker container prune -a -f
          docker image prune -a -f
          
          # Cleaning up inside minikube docker environment
          minikube ssh -- "docker container prune -a -f && docker image prune -a -f"
          
    